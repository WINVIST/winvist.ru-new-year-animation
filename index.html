<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Турбулентность — контраст</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#05060a; overflow:hidden; }
    #c { position:fixed; inset:0; width:100%; height:100%; display:block; }
    /* мягкий блик, завязанный на позицию курсора */
    .glow{
      position:fixed; inset:0; pointer-events:none;
      --mx:50%; --my:50%;
      background:
        radial-gradient(32vmax 32vmax at var(--mx) var(--my), rgba(255,255,255,0.12), transparent 55%),
        radial-gradient(90vmax 90vmax at 50% 50%, rgba(100,0,255,0.06), transparent 70%);
      mix-blend-mode: screen;
      filter: saturate(120%);
    }
    .ui{ position:fixed; left:12px; bottom:12px; font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#c9d0ff; opacity:.7; user-select:none; }
    .ui b{ color:#fff; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="glow"></div>
  <div class="ui" id="ui"></div>

<script>
(() => {
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  let w=0, h=0, t=0, animId=0, frame=0;

  // ===== utils =====
  const rand = (a,b)=>a + Math.random()*(b-a);
  const TAU = Math.PI*2;
  const clamp=(x,a,b)=>x<a?a:x>b?b:x;

  // lightweight Perlin-ish noise (value noise + smoothing)
  const N = 256, perm = new Uint8Array(N*2);
  for (let i=0;i<N;i++) perm[i]=i;
  for (let i=N-1;i>0;i--) { const j=(Math.random()* (i+1))|0; [perm[i],perm[j]]=[perm[j],perm[i]]; }
  for (let i=0;i<N;i++) perm[i+N]=perm[i];

  const fade = x => x*x*x*(x*(x*6-15)+10);
  function vhash(ix,iy){ return perm[(ix + perm[iy & 255]) & 255]/255; }
  function vnoise(x,y){
    const ix = Math.floor(x), iy = Math.floor(y);
    const fx = x-ix, fy = y-iy;
    const v00=vhash(ix,iy), v10=vhash(ix+1,iy), v01=vhash(ix,iy+1), v11=vhash(ix+1,iy+1);
    const ux=fade(fx), uy=fade(fy);
    const xa=v00*(1-ux)+v10*ux, xb=v01*(1-ux)+v11*ux;
    return xa*(1-uy)+xb*uy;
  }
  function fbm(x,y,oct=4){
    let amp=1, freq=1, sum=0, norm=0;
    for(let i=0;i<oct;i++){ sum += vnoise(x*freq,y*freq)*amp; norm += amp; amp*=0.5; freq*=2.03; }
    return sum/norm;
  }

  // ===== particles (snowflakes) =====
  const PCOUNT = 420;
  const parts = new Float32Array(PCOUNT*4); // x,y, vx, vy
  const life  = new Float32Array(PCOUNT);
  const size  = new Float32Array(PCOUNT);   // rendered size multiplier
  const spin  = new Float32Array(PCOUNT);   // angular speed
  const angle = new Float32Array(PCOUNT);   // current rotation
  const img   = new Image();
  img.src = 'snowflake-svgrepo-com.svg';

  function resize(){
    w = Math.floor(innerWidth * DPR); h = Math.floor(innerHeight * DPR);
    canvas.width = w; canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
  }

  function reset(i){
    parts[i*4+0] = rand(0,w);
    parts[i*4+1] = rand(-h*0.5, h*0.2);
    parts[i*4+2] = rand(-0.2, 0.2); parts[i*4+3] = rand(0.35, 1.2);
    life[i] = rand(0.8, 1.8) * 900;
    size[i] = rand(0.7, 1.6);
    spin[i] = rand(-0.01, 0.01);
    angle[i] = rand(0, TAU);
  }

  for(let i=0;i<PCOUNT;i++) reset(i);

  // ===== interaction & controls =====
  const pointer = { x:0, y:0, down:false };
  const glowEl = document.querySelector('.glow');
  const ui = document.getElementById('ui');

  function setGlow(x,y){
    if (!glowEl) return;
    const g = glowEl.style;
    g.setProperty('--mx', (x/innerWidth*100).toFixed(2) + '%');
    g.setProperty('--my', (y/innerHeight*100).toFixed(2) + '%');
  }
  window.addEventListener('pointermove', e=>{ pointer.x = e.clientX*DPR; pointer.y=e.clientY*DPR; setGlow(e.clientX, e.clientY); });
  window.addEventListener('pointerdown', ()=>pointer.down=true);
  window.addEventListener('pointerup', ()=>pointer.down=false);
  window.addEventListener('resize', resize, { passive:true });

  // ===== настройки =====
  let attract = false;           // false = отталкивает, true = притягивает

  function toggleMagnet(){ attract = !attract; updateUi(); }

  function updateUi(){
    if (!ui) return;
    ui.innerHTML = `M — магнит (${attract? 'притягивает' : 'отталкивает'}) • Клик — <b>буст</b>`;
  }

  // Клавиатура: M — магнит
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k === 'm') { toggleMagnet(); return; }
  });

  resize();
  updateUi();

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // константы магнитов
  const MAG_BASE = 5;        // сила магнита по умолчанию (притяжение/отталкивание)
  const MAG_BOOST = 20;       // буст при зажатой кнопке мыши для обоих режимов

  function step(){
    t += 0.0028; frame++;

    // базовая подложка — длинные шлейфы
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(3,4,7,0.12)';
    ctx.fillRect(0,0,w,h);

    const px = pointer.x, py = pointer.y;

    // рисуем снежинки поверх мягкого шлейфа
    ctx.globalCompositeOperation = 'lighter';

    for(let i=0;i<PCOUNT;i++){
      let x=parts[i*4], y=parts[i*4+1], vx=parts[i*4+2], vy=parts[i*4+3];

      // базовый «ветер» и гравитация
      const nx = (x/w)*1.2 + t*0.35;
      const wind = (fbm(nx, t*0.5, 3) - 0.5) * 0.28;
      let ax = wind;
      let ay = 0.012 + (0.008 * size[i]);

      // магнит: отталкивание/притяжение; усиление по клику работает ТОЛЬКО в режиме притяжения
      const dx = (px - x), dy = (py - y);
      const d2 = dx*dx + dy*dy + 25; // +softening радиус 5px
      const base = pointer.down ? MAG_BOOST : MAG_BASE; // единая сила для обоих режимов
      const sign = attract ? +1 : -1;
      let fx = sign * base * dx / d2;
      let fy = sign * base * dy / d2;
      // ограничим максимальное ускорение от магнита
      const fmag = Math.hypot(fx,fy);
      const fcap = pointer.down ? 2.0 : 0.8;
      if (fmag > fcap){ const k = fcap / fmag; fx *= k; fy *= k; }

      vx += ax + fx;
      vy += ay + fy;

      // лёгкое трение
      vx *= 0.984; vy *= 0.984;

      x += vx; y += vy;

      // перезапуск за пределами/по жизни
      if (--life[i] < 0 || x< -40 || y>h+40 || x>w+40) reset(i);
      else { parts[i*4]=x; parts[i*4+1]=y; parts[i*4+2]=vx; parts[i*4+3]=vy; angle[i]+=spin[i]; }

      // визуал: снежинки с лёгкой парящей прозрачностью
      const alpha = clamp(0.35 + vy*0.04, 0.25, 0.82);
      const sz = (18 * size[i]) * DPR;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle[i]);
      ctx.globalAlpha = alpha;
      if (img.complete) ctx.drawImage(img, -sz/2, -sz/2, sz, sz);
      else {
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.arc(0,0,sz*0.25,0,TAU);
        ctx.fill();
      }
      ctx.restore();
    }

    // вернуть нормальную композицию и добавить виньетку
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    const grd = ctx.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h)*0.72);
    grd.addColorStop(0,'rgba(0,0,0,0)');
    grd.addColorStop(1,'rgba(0,0,0,0.12)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);

    animId = requestAnimationFrame(step);
  }

  animId = requestAnimationFrame(step);

  // остановка при скрытии вкладки
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden) cancelAnimationFrame(animId);
    else animId = requestAnimationFrame(step);
  }, { passive:true });
})();
</script>
</body>
</html>
